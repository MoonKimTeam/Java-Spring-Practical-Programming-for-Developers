# 객체의 종류

- VO란 어떤 객체일까요 ?
- DTO란 어떤 객체일까요 ?
- DAO란 어떤 객체일까요 ?
- Entity란 어떤 객체일까요 ?

## VO (Value Object: 값 객체)

```java
// 값 객체로 선언된 Color 클래스
import java.util.Objects;

public final class Color {

    public final int r;
    public final int g;
    public final int b;

    public Color(int r, int g, int b) {
        if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
            throw new IllegalArgumentException("RGB should be 0 to 255");
        }
        this.r = r;
        this.g = g;
        this.b = b;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        final Color color = (Color) o;
        return r == color.r &&
               g == color.g &&
               b == color.b;
    }

    @Override
    public int hashCode() {
        return Objects.hash(r, g, b);
    }
}

```


Color 클래스가 V0라는 것은 Color 클래스로 만들어진 객체를 숫자 1, 2, 3, 4같은 값과 같이 볼 수 있다는 의미입니다.  
즉, Color는 객체지만 동시에 값입니다. 그래서 값 객체라고 부릅니다.  

그럼 값에는 어떤 특징들이 있을까요?  
소프트웨어 설계자 입장에서 값은 불변성, 동등성, 자가 검증이라는 특징이 있습니다.

| 값의 특징 | 설명 |
|------------|------|
| 불변성 | 값은 변하지 않습니다. 예를 들어, 숫자 1은 영원히 숫자 1입니다. |
| 동등성 | 값의 가치는 항상 같습니다. 예를 들어, 모든 숫자 1은 적혀 있는 위치나 시간과 관계없이 항상 같은 숫자 1입니다. |
| 자가 검증 | 값은 그 자체로 올바릅니다. 예를 들어, 숫자 1은 그 자체로 올바른 숫자입니다. 이는 ‘1은 사실 1.01이지 않을까?’와 같은 고민을 할 필요가 없다는 의미입니다. |

### 불변성

객체의 불변성은 복잡하고 어렵게 생각할 개념이 아니기도 합니다.  
왜냐하면 객체를 진정한 의미의 불변으로 만들려고 노력하는 것은 그것 나름대로 에너지 낭비이기 때문입니다.  
VO의 불변성이라는 특징을 완벽하게 지키는 100점짜리 VO를 만들려고 노력할 필요도 없습니다.  
**중요한 것은 100점짜리 VO를 만드는 것이 아니라 불변성이 지닌 '가치를 좇는 것'입니다.**
불변성을 강조하는 이유는 간단합니다. 객체를 신뢰할 수 있게 만들기 위함입니다.  
불변성을 가진 객체는 내부 상태가 변경되지 않습니다. 덕분에 다른 객체와 협력하는 과정에서 항상 예측 가능한 방식으로 동작합니다.

### 동등성

Color 클래스는 equals와 hashCode 메서드를 오버라이딩하고 있습니다.  
이는 값이 갖고 있는 동등성이라는 가치 때문입니다.

```java
Color green1 = new Color(0, 1, 0);
Color green2 = new Color(0, 1, 0);
System.out.println(green1 == green2); // equals와 hashCode를 오버라이드하지 않으면 false가 나옴
```

green1 == green2는 두 개의 초록색 객체가 있고 두 객체가 같은지 아닌지 확인하는 코드입니다.  
의미론적으로 초록색이라는 색상은 같은 것이므로 누군가는 같다고 대답할 것입니다. 하지만 누군가는 다른 참조 값을 갖는 객체이니 다르다고 볼 것입니다.  
**VO는 이 경우에 내재된 의미가 같다면 같은것이라고 합니다.**

따라서 VO를 만들기 위해 자바에서는 객체 간 비교에 사용되는 equals나 hashCode를 오버라이딩할 필요가 있습니다.  
오버라이딩하지 않는다면 equals와 hashCode 메서드는 객체의 참조값, 즉 메모리상의 주솟값을 이용해 비교합니다.
**이는 VO의 설계 의도와 일치하지 않습니다.**

> 동등성 vs 식별자  
> **VO에는 식별자를 넣어서는 안됩니다.**  
> 즉, VO는 id 같은 식별자 필드를 멤버 변수로 가지고 있어서는 안됩니다.  
> 식별자의 정의에 따르면 id가 같으면 같은 객체로 판단해야 하는데, VO의 정의에 따르면 두 객체의 상태가 같은지 확인해야 합니다.

### 자가 검증

자가 검증이란 말 그대로 클래스 스스로 상태가 유효한지 검증할 수 있음을 의미합니다.  
즉, 유효하지 않은 상태의 객체가 만들어질 수 없다는 것을 의미합니다.

**자가 검증이 완벽한 객체라면 외부에서 이 객체를 사용할 때 상태에 이상한 값이 들어 있지는 않을지 노심초사하지 않아도 됩니다.**  
상태 검증을 위해 if-else문, try-catch 문을 사용하지 않아도 된다는 것입니다.
**따라서 VO의 생성자에는 반드시 유효한 상태 값이 들어오는지 검증하는 코드가 있어야 합니다.**

## DTO

DTO는 다른 객체나 시스템에 데이터를 구조적으로 만들어 전달하기 위한 객체입니다.  
DTO는 오롯이 데이터를 효과적으로 전달히는 데만 집중합니다. 그 밖의 능동적인 역할이나 책임을 갖고 있지 않습니다.  
그러므로 DTO에는 데이터를 읽고 쓰는 것 외에 다른 비즈니스 로직이 들어가서는 안 됩니다.

### 오해 1. DTO는 프로세스 계층 간 데이터 이동에 사용된다.

분명히 DTO는 API 통신이나 데이터베이스 통신에 사용할 수 있습니다. 하지만 그것이 DTO의 목적은 아닙니다.  
DTO는 조금 더 단순하고 범용적인 개념입니다. DTO의 목적은 데이터를 전달하는 것입니다.  
그러므로 데이터를 전달하고 싶은 상황이라면 어디서든 사용될 수 있습니다.
**DTO가 어디에서 사용되느냐는 중요하지 않습니다. 데이터 전송이 필요한 모든 곳에서 사용할 수 있습니다.**

### 오해 2. DTO는 게터, 세터를 갖고 있다.

게터, 세터는 내부 데이터를 전달하기 위한 방법 중 하나일 뿐입니다.  
게터, 세터 없이도 내부 데이터를 전달할 수 있습니다. 바로 멤버 변수를 public으로 선언하는 것입니다.  
**자바가 익숙한 개발자라면 본능적으로 멤버 변수가 public으로 선언된 것을 참지 못합니다. 왜냐하면 대부분의 자바 프로젝트가 '모든 멤버 변수는 private으로 선언돼 있어야 한다라는 규칙을 관행적으로 따르고 있기 때문입니다.**  

```java
@Getter
@Setter
public class UserCreateRequest {
    private String username;
    private String password;
    private String email;
    private String address;
    private String gender;
    private int age;
}
```

이 코드는 괜찮은 코드인가요? 아마도 여러분은 높은 확률로 이런 식의 코드를 접해본 적이 많을 것입니다. 그런데 이런 코드를 만드는 것이 무슨 의미가 있을까요?  
완전히 무의미한 행동입니다. 멤버 변수를 private으로 선언했는데 게터, 세터를 만들어 사용하면, private 선언이 소용이 없습니다.

> 그렇다고 앞으로 멤버 변수를 public으로 지정하라고 권장하는 것은 아닙니다.  
> 예를 들어, 사용자의 이메일 주소를 가져오기 위해 user.getEmail() 메서드를 호출하는 것과 user.email로 변수에 직접 접근하는 것은 분명히 다릅니다.  
> email은 속성에 의존하는 것이고 getEmail()은 행동에 의존하는 것이기 때문입니다.


### 오해 3. DTO는 데이터베이스에 데이터를 저장하는 데 사용되는 객체다.

데이터라는 말은 컴퓨터 공학 어디서든 사용되는 개념입니다. 그리고 DTO는 이름에서부터 그것의 역할과 목적을 너무나도 잘 설명하고 있습니다.  
말 그대로 데이터를 전송하기 위한 객체인 것입니다. 그 이상, 그 이하의 의미도 없습니다.  


## DAO

DA0는 말 그대로 데이터에 접근하기 위해 만들어진 객체입니다.   
복잡하고 번거로운 데이터베이스 접근 관련 로직을 전문적으로 처리하기 위해 만들어진 객체로서 스프링 개발자에게 친숙한 리포지터리(Repository)와 같은 개념이라 보면 됩니다.  
**DAO가 만들어진 목적은 무엇일까요? 단순합니다. 도메인 로직과 데이터베이스 연결 로직을 분리하기 위해서입니다.**  

## 엔티티

JPA가 유명해지면서 개발 세계에 거대한 오해가 하나 생겼습니다. 바로 엔티티를 JPA 엔티티와 동일시한다는 것입니다.  
그런데 애석하게도 이런 식의 접근은 틀렸습니다. 왜냐하면 엔티티는 JPA에서 만들어진 용어가 아니기 때문입니다.  
엔티티를 설명하기에 앞서 헷갈리기 쉬운 세 가지 엔티티를 소개하겠습니다.

1. 도메인 엔티티
2. DA 엔티티
3. JPA 엔티티

### 도메인 엔티티

은행에서 사용하는 소프트웨어를 만들기로 했다면 은행이 도메인입니다. 왜냐하면 소프트웨어가 은행이라는 비즈니스 영역을 다루기 때문입니다.  
그러면 이 소프트웨어에는 어떤 개념이 사용될 수 있을까요? 은행 소프트웨어는 Account. Transaction. Money같은 개념이 사용될 수 있습니다.  
그리고 이 개념을 클래스로 만들 수 있습니다. 이때 이렇게 만들어진 개념 모델들을 '도메인 모델'이라고 부릅니다.  
**즉, 도메인 모델은 어떤 도메인 문제를 해결하고자 만들어진 클래스 모델입니다.**

그런데 이러한 도메인 모델 중에는 유독 특별한 모델이 있습니다. 예를 들어. 도메인 모델 중 Account나 Transaction 같은 모델을 생각해 봅시다.  
이 모델들은 Money 같은 모델과 약간 다릅니다. Account나 Transaction은 식별자가 존재할 수 있으며, 도메인 모델에 걸맞는 조금은 특화된 비즈니스 로직을 가질 수 있습니다.  
나아가 생애주기(lifecycle)를 가질 수도 있을 것입니다. 그래서 도메인 모델 중에서도 이렇게 특별한 기능을 갖고 있는 모델들을 도메인 엔티티라고 부릅니다.
**도메인 엔티티는 식별 가능하고 비즈니스 로직을 갖고 있으며, 조금 특별하게 관리되는 클래스로 만들어진 객체라고 볼 수 있습니다.**

### DB 엔티티

이 용어는 도메인 엔티티의 개념과 상관없이 원래 관계형 데이터베이스 분야에서 어떤 유무형의 객체를 표현하는 데 사용했던 용어입니다.  

### JPA 엔티티

관계형 데이터베이스에 있는 데이터를 객체로 매핑하는 데 사용되는 클래스를JPA 엔티티라고 부르는데, 이때 클래스에 @Entity라는 애너테이션을 지정합니다.  
JPA 엔티티를 도메인 엔티티나 DB 엔티티와 비교하자면 DB 엔티티에 더 가까운 개념으로 이해할 수 있습니다.     
**그래서 '엔티티는 JPA의 ©Entity로 선언된 클래스다'라는 식의 답변은 틀렸다고 말하는 것입니다.**  
















