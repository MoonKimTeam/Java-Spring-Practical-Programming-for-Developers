# 포트-어댑터 패턴

의존성 역전 원칙은 포트-어댑터(ports and adapters) 패턴이라 불리기도 합니다.  
물론 엄밀히 말해 의존성 역전 원칙과 포트-어댑터 패턴은 다른 개념입니다. 하지만 두 개념이 만들어진 이유와 결과가 상당히 비슷하니 그렇게 부를 수 있다는 말입니다.  
포트-어댑터 패턴은 두 시스템이 상호 작용할 때 가운데 추상（인터페이스）을 두고 통신하도록 만들어 시스템 간의 종속을 피하도록 만드는 것을 의미합니다.  
이 패턴을 이용하면 기존 코드에 외부 라이브러리를 추가하거나 기능을 확장하려 할 때 기존 코드에는 영향이 가지 않게 할 수 있어 매우 유용합니다.

## 출력 포트-출력 어댑터

<img width="604" height="288" alt="Image" src="https://github.com/user-attachments/assets/75734230-d6c9-4195-b42c-7b4281cf8201" />

포트를 출력 포트라 부르고 포트를 구현하는 구현체는 출력 어댑터라 부를 수 있습니다.  
이때 포트와 어댑터라는 이름에 출력이라는 용어가 붙은 이유는 실행 객체 입장에서 포트에 메시지를 전달하는 행위가 어떤 새로운 결과를 출력하기 위함이기 때문입니다.    
**명세(출력 포트)와 구현(출력 어댑터)을 분리함으로써 실행 객체는 구현에 의존하지 않게 변합니다.**  

## 입력 포트-입력 어댑터

<img width="435" height="274" alt="Image" src="https://github.com/user-attachments/assets/f4e0273f-ffcd-4839-bbb5-cb2fa6b93007" />

구현체는 자신을 실행할 실행 객체가 무엇이 될지 알 수 없습니다. 실행객체는 얼마든지 다른 객체로 변경될 수 있기 때문입니다.  
그렇기 때문에 구현체 입장에서 입력 포트를 통해 메시지를 전달하는 객체는 마치 출력 포트와 출력 어댑터 관계에서 그랬던 것처럼 시시각각 변하는 어댑터라 볼 수 있습니다.  
입력 포트-입력 어댑터 관계도 출력 포트-출력 어댑터와 마찬가지로 어댑터의 변경이 자유롭습니다.

## 정리

포트 어댑터 패턴은 내부 시스템이나 컴포넌트가 외부 시스템과 통신하는 방식을 추상화합니다.   
외부 시스템이 변경돼도 내부 시스템에 영향을 주지 않게 만듭니다. 이 목적은 의존성 역전 원칙과 같습니다. 따라서 의존성 역전은 포트-어댑터 패턴이라고 부를 수 있습니다.  

참고로 포트-어댑터 패턴과 디자인 패턴에서 말하는 어댑터 패턴은 다른 것입니다.   
포트-어댑터 패턴은 시스템 아키텍처 수준에서 외부 시스템과의 인터페이스를 추상화하는 데 사용됩니다.    
한편 디자인 패턴의 어댑터 패턴은 클래스나 객체 간의 인터페이스 불일치를 해결하는 데 사용됩니다.   
즉, 어댑터 패턴은 시스템에 새로운 라이브러리나 클래스가 도입될 때 기존 코드를 변경하지 않고 새로운 클래스를 통합하는 목적으로 사용됩니다.

# 클린 아키텍처

로버트 C. 마틴이 제시하는 클린 아키텍처의 생김새는 대략적으로 다음과 같은 형태입니다.

<img width="384" height="349" alt="Image" src="https://github.com/user-attachments/assets/4a8f69f0-d8e3-41e3-9b3f-c3e7b3312588" />

1. Entities: 시스템의 비즈니스 로직과 객체가 정의됩니다. 시스템의 핵심이므로 와부의 영향을 받지 않아야 하며, 가장 변하지 않아야 하는 영역입니다.
2. Use cases: 비즈니스 흐름과 엔티티 간의 상호작용을 관리합니다. 사용자의 요청을 처리하고 그에 따라 엔터티를 조작합니다.
3. Interface adapters: 외부 인터페이스와 Use Cases를 연결하는 역할을 합니다. 외부의 요청을 내부 형식으로 변환하거나 내부의 데이터를 외부 형식으로 변환합니다,
4. Frameworks & Drivers: 시스템의 외부와 상호 작용합니다. 주로 사용자와 상호 작용하거나 데이터베이스나 외부 서비스 등과 통신하는 역할을 담당합니다.

클린 아키텍처는 위와 같은 기준으로 시스템의 경계를 나누고, 이 경계의 방향이 항상 단방향이 될 것을 강조합니다.  
더불어 의존 방향이 항상 바깥 원에서 안쪽 원을 향하도록 강조합니다. 내부의 원이 외부의 원에 관해 알아서는 안 된다는 말입니다. 

특이한 점은 클린 아키텍처에서는 실제 개발 단계에서 구체적으로 어떤 식으로 개발하는지 설명하지 않는다는 것입니다.  
클린 아키텍처는 개념적인 해결책만 제시할 뿐입니다. 이를 위한 실천적인 아키텍처는 따로 존재합니다. 대표적으로 헥사고날 아키텍처와 양파 아키텍처가 있습니다.  
**즉, 클린 아키텍처가 추상이라면 헥사고날 아키텍처나 양파 아키텍처는 구현체라고 볼 수 있습니다.**

# 소프트웨어 엔지니어

모든 코드에는 기대 수명이 있습니다. 이 기대 수명은 코드의 성격마다 다른데 어떤 코드의 기대 수명은 30분이 되기도 하며, 1주일이 되기도 합니다.  
조금 길다면 한 달이 되기도 하고, 정말 길게는 수 년, 수 십년, 수백 년이 되기도 합니다.  
**'소프트웨어 엔지니어에 관한 주제로 이야기하면서 프로그램의 기대 수명을 이야기하는 이유는 '프로그램의 주요 요구사항', '개발 난이도', '요구사항의 복잡도 대비 얻을 수 있는 비즈니스 가치'가 무엇이냐에 따라 투자해야 하는 시간이 기대 수명에 따라 다르기 때문입니다.**  
그래서 당장 오늘 만들어서 오늘만 사용할 스크립트를 작성하면서 복잡한 테스트 코드를 작성할 필요는 없습니다. 더불어 이러한 코드에는 객체지향을 적용할 필요도 없습니다. 이 스크립트는 앞으로 꾸준히 유지보수할 대상이 아니기 때문입니다.  
수십 수백 년을 바라보는 프로그램이라면 당장 제대로 동작하는 것만 신경 쓸 것이 아니라 이러한 외부적인 변화에도 대응할 수 있어야 합니다.

# 실용주의

실무에서 소프트웨어를 개발하는 이유는 그냥 심심해서가 아닙니다. 대부분 명확한 목표가 있고 어떤 비즈니스 문제를 해결하기 위함입니다.  
그러니 소프트웨어는 비즈니스 문제를 해결할 수 있어야 합니다. 사용자에게 어떤 비즈니스 가치를 전달할 수 있어야 합니다.  
우리는 비즈니스 문제를 해결하기 위해 평소 하는 것처럼 소프트웨어를 개발해서 가치를 전달할 수도 있지만 사용자가 겪는 문제를 오프라인에서 해결 해줌으로써 가치를 전달할 수도 있습니다.  
**비즈니스 문제를 해결하기 위한 도구가 다양한 만큼, 소프트웨어로 문제를 해결하려 할 때 그 안에서도 정말 다양한 방법이 있습니다.**  
결국 우리의 목표는 가치를 전달하는 것이기 때문에 그 형태가 어떤지는 중요하지 않습니다.



