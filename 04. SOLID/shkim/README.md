# SOLID

- 단일 책임 원칙 (SRP)
- 개방 폐쇄 원칙 (OCP)
- 리스코프 치환 원칙 (LSP)
- 인터페이스 분리 원칙 (ISP)
- 의존성 역전 원칙 (DIP)

각 원칙은 객체지향 언어에서 좋은 설계를 얻기 위해 개발자가 지켜야 할 규범과 같은 것을 이야기합니다.  
그리고 각 원칙의 목표는 소프트웨어의 유지보수성과 확장성을 높이는 것입니다.  
설계 관점에서 코드의 유지보수성을 판단할 때 사용할 수 있는 조금 더 실무적인 세 가지 맥락이 있습니다.

1. 영향 범위: 코드 변경으로 인한 영향 범위가 어떻게 되는가?
2. 의존성: 소프트웨어의 의존성 관리가 제대로 이뤄지고 있는가?
3. 확장성: 쉽게확장 가능한가?

즉, SOLID는 이 질문의 답을 알려주는 원칙인 것입니다.

## SOLID 소개

### 단일 책임 원칙

> 클래스를 변경해야 할 이유는 단 하나여야 합니다.  
> -로버트 C. 마틴

과하게 집중된 책임은 피하고 분할해야 합니다. 이러한 맥락에서 단일 책임 원칙을 따르라는 말은 클래스가 특정 역할을 달성하는 데만 집중할 수 있게 하라는 의미입니다.  
클래스에 할당된 책임이 하나라면 코드를 이해하는 것도 쉬워집니다. 코드 수정이 필요하다면 특정 클래스나 모듈만 수정하면 됩니다. 수정하는 것도 쉬워지는 것입니다.  

**다시 말하면 단일 책임 원칙은 결국 '변경'과 연결됩니다.**  
변경으로 인한 영향 범위를 최소화하는 것이 이 원칙의 목적입니다.  
소프트웨어는 복잡계이므로 빈번하게 들어오는 요구사항 변경을 효율적으로 처리하는 것이 중요합니다.

**여기서 책임이란 무엇이고 이를 어떻게 나눌지 기준이 필요합니다.**  
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 합니다.  
액터는 메시지를 전달하는 주체입니다. 그리고 단일 책임 원칙에서 말하는 책임은 액터에 대한 책임입니다.  
즉, 단일 책임 원칙을 이해하려면 책임이 무엇인지 이해하려 노력하기보다는 오히려 액터에 집중해야 합니다.
즉, 어떤 클래스를 사용하게 될 액터가 한 명이라면 단일 책임 원칙을 지키고 있는 것이고 여럿이라면 위반하고 있는 것입니다.  
그리고 액터가 하나일 수 있다면 클래스를 변경할 이유도 하나로 고정됩니다.

### 개방 폐쇄 원칙

> 클래스의 동작을 수정하지 않고확장할 수 있어야합니다.  
> -로버트 C. 마틴

개방 폐쇄 원칙은 주로 확장에 관한 이야기를 다룹니다.  
이 원칙의 주된 목적은 기존 코드를 수정하지 않으면서도 확장이 가능한 시스템을 만드는 것입니다.  
코드를 확장하고자 할 때 취할 수 있는 최고의 전략은 기존 코드를 아예 건드리지 않는 것입니다.  

<img width="841" height="854" alt="Image" src="https://github.com/user-attachments/assets/5854501e-2eb2-4c5d-b4bc-363ccfad9ce4" />

### 리스코프 치환 원칙

> 파생 클래스는 기본 클래스를 대체할 수 있어야 합니다.  
> -로버트 C. 마틴

이 원칙은 한 문장으로 정의하면 '기본 클래스의 계약을 파생 클래스가 제대로 치환할 수 있는지 확인하라'는 원칙입니다.  

```java
// 코드 4.2 Rectangle을 상속하는 Square

@Getter
@Setter
@AllArgsConstructor
class Rectangle {
    protected long width;
    protected long height;

    public long calculateArea() {
        return width * height;
    }
}

class Square extends Rectangle {

    public Square(long length) {
        super(length, length);
    }
}

public class Main {
    public static void main(String[] args) {
        Rectangle rectangle = new Square(10);
        rectangle.setHeight(5);

        // 다음 코드의 실행 결과는 50이 나올 것입니다. 원하는 결과가 맞나요?
        System.out.println(rectangle.calculateArea());
    }
}

```

이 예시는 리스코프 치환 원칙을 설명하면서 보여주는 대표적인 리스코프 치환 원칙의 위반 사례입니다.  
현재의 정사각형 클래스는 직사각형 클래스의 모든 동작을 완전히 대체하지 못합니다.

### 인터페이스 분리 원칙

> 클라이언트별로 세분화된 인터페이스를 만드세요.  
> -로버트 C. 마틴 

인터페이스 분리 원칙은 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙입니다.  
즉, 어떤 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 않아야 한다는 말입니다.  
이 원칙은 개발자들이 하나의 인터페이스로 모든 것을 해결하려고 할 때 위배됩니다.

```java
public class LifecycleBean implements
    BeanNameAware,
    BeanFactoryAware,
    InitializingBean,
    DisposableBean {

    // ...

}
```

### 의존성 역전 원칙

> 구체화가 아닌 추상화에 의존해야 합니다.  
> -로버트 C. 마틴 

1. 상위 모듈은 하위 모듈에 의존해서는 안 된다 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
2. 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.

## 의존성

> 의존: 다른 객체나 함수를 사용하는 상태

다시 말해 어떤 객체가 다른 코드를 사용하고 있기만 해도 이를 가리켜 의존하고 있다고 볼 수 있습니다.
그렇기 때문에 소프트웨어는 의존하는 객체들의 집합이라고 볼 수 있습니다. 객체지향에서 객체들은 필연적으로 협력하는데 서로를 사용하기 때문입니다.

컴퓨터 공학에는 의존을 표현하는 또 다른 용어가 있습니다. 바로 **결합**이라는 용어입니다.  
결합은 결합이 어떻게 되어 있느냐에 따라 강결합으로 평가되기도 하고 약결합으로 평가되기도 합니다.  
일반적으로 소프트웨어 세계에서는 결합도가 약하면 약할수록 좋다고 평가합니다.

**놀랍게도 객체를 사용하면서도 결합을 약하게 사용할 수 있는 방법이 있습니다.**  
바로 의존성 주입입니다.

### 의존성 주입

의존성 주입은 말 그대로 필요한 의존성을 외부에서 넣어주는 것을 의미합니다.  

```java
class HamburgerChef {
    private Bread bread;
    private Meat meat;
    private Vegetable vegetable;
    private Sauce sauce;

    public HamburgerChef(
        Bread bread,
        Meat meat,
        Vegetable vegetable,
        Sauce sauce) {
        this.bread = bread;
        this.meat = meat;
        this.vegetable = vegetable;
        this.sauce = sauce;
    }
    
    public Food make() {
        return Hamburger.builder()
            .bread(bread)
            .meat(meat)
            .vegetable(vegetable)
            .sauce(sauce)
            .build();
    }
}
```

메서드가 필요한 협력 객체를 외부에서 전달받아 사용하도록 바뀌었습니다.  
외부에서는 협력 객체를 넣어줄 수 있으니 이러한 객체를 주입할 수 있게 됐습니다. 이런 상황을 가리켜 의존성 주입이 사용됐다고 합니다.  

### 의존성 역전

<img width="371" height="88" alt="Image" src="https://github.com/user-attachments/assets/8d800d91-3680-402f-81a3-51541d3ac47f" />  
<img width="387" height="184" alt="Image" src="https://github.com/user-attachments/assets/f7d25e78-58e5-41a9-8f98-8779d6f66b63" />

화살표가 들어오는 방향에서 나가는 방향으로 바뀌었습니다.  
화살표는 의존 방향을 나타내는데, 의존의 방향이 역전됐다고 할 수 있는것입니다.
추상화를 사용하고 추상을 사용하도록 코드를 변경했을 뿐인데, 원래는 의존을 당하던 객체가 의존을 하는 객체로 바뀌었습니다.  
**그래서 의존성 역전 원칙은 세부 사항에 의존하지 않고 정책에 의존하도록 코드를 작성하라라는 말로 바꿔 말할 수 있습니다.**

## SOLID와 객체지향

SOLID 원칙이 추구하는 것은 객체지향 '설계'입니다.  
그래서 SOLID가 추구하는 방향과 객체지향이 추구하는 방향은 조금 다릅니다.

객체지향의 핵심은 역할, 책임, 협력입니다. 한편 SOLID는 객체지향 방법론 중 하나로, 변경에 유연하고 확장할 수 있는 코드를 만드는 데 초점을 둡니다.  
쉽게 말해 SOLID는 설계 원칙이고, 설계 원칙은 응집도를 높이고 의존성을 낮추는 방법에 집중합니다.















