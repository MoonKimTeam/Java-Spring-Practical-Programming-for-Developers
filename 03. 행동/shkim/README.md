# 행동

객체를 구분 짓는 요인은 데이터가 아닙니다. 행동입니다.  
우리는 객체를 만들 때 데이터보다는 행동에 집중해야 합니다.  
**데이터가 객체를 결정하지 않습니다. 행동이 객체를 결정합니다.**  

> 행동을 먼저 고민하면 Car나 Bicycle 같은 구체적인 이름보다 Vehicle(탈것)이라는 역할이 나옵니다.  
> 행동을 고민하는 것은 자연스럽게 역할을 고민하게 만듭니다.  
> 따라서 어떤 행동을 할 수 있는지가 곧 역할을 만듭니다. 그리고 이러한 역할이 모여 객체를 정의하는 것입니다.


## 덕 타이핑

객체지향은 행동을 강조합니다. 그리고 이 사실을 뒷받침하는 데 사용하기 좋은 용어가 하나 있습니다.  
바로 **덕 타이핑**입니다. 덕 타이핑의 개념은 덕 테스트에서 유래했습니다.

> 덕 테스트: 만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.

개발자 관점에서 이 말을 해석하자면, 행동이 같다면 같은 클래스로 부르겠다라는 의미입니다.  
**행동이 곧 역할을 정의하고, 역할이 곧 객체를 정의합니다.**

## 행동과 구현

비교적 간단해 보이는 changeDirection 메서드를 구현해 보겠습니다.  
이 메서드는 방향을 바꾸는 메서드인데, 이 메서드를 호출하면 그 결과로 자동차의 각도를 변경합니다.

```java
public class Car {

    private int degree; // 자동차의 각도 (0도 ~ 360도)
    
    public void drive() {}

    public void changeDirection(float amount) {
        float result = (degree + amount) % 360;
        if (result < 0) {
            result += 360;
        }
        return result;
    }

    public void accelerate(float speed) {}

    public void decelerate(float speed) {}
}
```

Car 클래스에 속성이 생겼습니다. 메서드를 구현하려고 했더니 데이터 위주의 사고로 돌아온 것입니다.  
여기서 한 가지 사실을 알 수 있습니다. 행동의 구현을 고민했더니 결국 이 클래스가 어떤 값을 갖고 있어야 하는지를 고민하게 됐다는 것입니다.  
그리고 이는 그다지 반가운 현상이 아닙니다. 기껏 행동 위주로 사고하겠다고 다짐했었는데 구현을 고민했더니 곧바로 데이터 위주의 사고로 되돌아왔습니다.

**이러한 현상이 일어난 이유는 명확합니다. 구현을 고민했기 때문입니다.**  
행동을 고민하면서 구현이나 알고리즘을 고민해서는 안 됩니다. 행동을 고민하는 순간에는 순수하게 이 클래스에 어떤 동작을 시킬 수 있을 것인지만 고민하는 것이 좋습니다.  
**이럴 때 사용할 수 있는 최고의 문법이 하나 있습니다.**  
바로 인터페이스입니다. 자바의 인터페이스를 활용하면 구현 없이도 메서드를 정의할 수 있습니다.

```java
public interface Car {
    void drive();
    void changeDirection(float amount);
    void accelerate(float speed);
    void decelerate(float speed);
}
```

> 초기 설계 단계에서는 상세한 구현은 무시해도 괜찮습니다.  
> 자동차를 예로 들면, 자동차는 원하는 속도와 방향으로 안전하게 굴러가기만 하면 됩니다. 내부 구현은 솔직히 알 게 뭔가요?  
> 내부의 상세 구현은 Car 인터페이스의 구현체를 개발하는 분이 협의한 요구사항에 맞춰 알아서 개발할 것입니다.

## 인터페이스

**이쯤에서 오해할 만한 여지를 하나 해결하고 가겠습니다. 바로 인터페이스와 행동은 다르다는 것입니다.**  
인터페이스는 외부에서 어떤 객체에게 행동을 시키고자 할 때 메시지를 보낼 수 있는 창구일 뿐입니다.  

> 인터페이스란 '나를 조작하고 싶다면 이런 메시지를 보내면 된다'라고 와부에 알려주는 수단입니다.

대표적인 인터페이스로 API가 있습니다.  
API는 애플리케이션을 조작하고 싶을 때 어떻게 메시지를 보내면 되는지 알려주는 것입니다.  
그리고 재미있게도 이러한 맥락에서 봤을 때 쉽게 이해되는 사실이 두 가지 있습니다.

- 자바 인터페이스에는 private 선언이 불가능하다. 인터페이스에 private 선언이 있으면 컴파일 에러가 발생합니다.
- 인터페이스의 메서드에 public을 지정하면 IntelliJ IDEA 같은 IDE에서는  public으로 선언할 필요가 없다고 안내합니다.

## 행동과 역할

***자동차 클래스를 만들어 줄 수 있나요?*** 같은 요청을 받았을 때 다음과 같은 질문을 역으로 해야합니다.

- 자동차는 어떤 행동을 하는 객체인가요 ?
- 꼭 자동차이어야 하나요 ?
- 자동차라는 클래스를 만들어서 달성하려는 목표가 뭔가요 ?

그렇다면 여러분은 그제야 클라이언트가 진짜로 원하는 것은 '탈것'이라는 사실을 알게 될 것입니다.  
그리고 다음과 같은 인터페이스를 만들 수 있을 것입니다.

```java
public interface Vehicle {
    
    void ride();

    void run();

    void stop();
}
```

역할에 집중하면 훨씬 유연한 설계를 얻을 수 있습니다.  
그래서 역할과 구현은 반드시 구분해야 하며, 이 같은 구분을 위한 출발점은 어떤 질문을 하느냐입니다.  
**구현에 집중한 코드는 확장되는 요구사항에 유연하게 대처할 수 없습니다.**  
역할에 집중해야 유연한 설계를 얻을 수 있습니다.

## 메서드

```java
// 코드 3.11 인터페이스를 통해 통신하면 구현 객체가 무엇이냐에 따라 실행할 메서드가 달라진다.

class Car implements Vehicle {

    void ride() {}

    void run() {}

    void stop() {}
}

class Bicycle implements Vehicle {

    void ride() {}

    void run() {}

    void stop() {}
}

class User {

    void ride(Vehicle vehicle) {
        // User 클래스는 어떤 객체의 메서드를 실행하게 될까요?
        // Car 객체의 ride() 메서드? Bicycle 객체의 ride() 메서드?
        // 실제로 코드가 실행되기 전까지는 알 수 없습니다.
        vehicle.ride();
    }
}

```

vehicle.ride()를 호출하지만 코드가 실행되기 전까지는 실제로 어떤 메서드가 호출될지 모릅니다.  
**어찌 보면 이 같은 당연한 사실 때문에 메서드와 함수는 다른 개념이 됩니다.**  

> 함수는 입력값(input)과 출력값(output) 사이의 대응 관계를 나타냅니다. 
> 함수의 각 입력값은 정확히 하나의 출력값으로 대응됩니다.

함수는 같은 입력에 대해 항상 같은 출력을 해야 합니다. 같은 입력값으로 함수를 실행했을 때 다른 출력값이 나와서는 안 됩니다.  
즉, 같은 입력에 대해 두 개의 출력을 갖는 함수가 있어서는 안 됩니다.

객체지향에서 객체들은 메시지를 통해 소통합니다. 이러이러한 인수를 건네줄 테니 알아서 일을 해달라고 부탁하는 것입니다.  
즉, 객체는 협력 객체에 메시지만 보낼 뿐입니다. 실제로 어떤 **방법(method)**으로 일을 어떻게 처리할지는 객체가 정합니다.  








